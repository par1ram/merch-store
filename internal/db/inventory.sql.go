// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: inventory.sql

package db

import (
	"context"
)

const getInventoryByEmployeeID = `-- name: GetInventoryByEmployeeID :many
SELECT 
  i.employee_id,
  i.merch_id,
  m.name AS merch_name,
  i.quantity
FROM inventory i
JOIN merch m ON i.merch_id = m.id
WHERE i.employee_id = $1
ORDER BY m.name
`

type GetInventoryByEmployeeIDRow struct {
	EmployeeID int32
	MerchID    int32
	MerchName  string
	Quantity   int32
}

// ----------------------------------------------------------
// GetInventoryByEmployeeID возвращает список купленных товаров сотрудника.
func (q *Queries) GetInventoryByEmployeeID(ctx context.Context, employeeID int32) ([]GetInventoryByEmployeeIDRow, error) {
	rows, err := q.db.Query(ctx, getInventoryByEmployeeID, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInventoryByEmployeeIDRow
	for rows.Next() {
		var i GetInventoryByEmployeeIDRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.MerchID,
			&i.MerchName,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertInventory = `-- name: UpsertInventory :exec
INSERT INTO inventory (employee_id, merch_id, quantity)
VALUES ($1, $2, $3)
ON CONFLICT (employee_id, merch_id)
DO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity
`

type UpsertInventoryParams struct {
	EmployeeID int32
	MerchID    int32
	Quantity   int32
}

// UpsertInventory добавляет товар в инвентарь сотрудника или обновляет количество,
// если запись для данной пары (employee_id, merch_id) уже существует.
func (q *Queries) UpsertInventory(ctx context.Context, arg UpsertInventoryParams) error {
	_, err := q.db.Exec(ctx, upsertInventory, arg.EmployeeID, arg.MerchID, arg.Quantity)
	return err
}
