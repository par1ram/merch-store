// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: employees.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (username, password_hash)
VALUES ($1, $2)
RETURNING id, username, coins, password_hash
`

type CreateEmployeeParams struct {
	Username     string
	PasswordHash string
}

type CreateEmployeeRow struct {
	ID           int32
	Username     string
	Coins        int32
	PasswordHash string
}

// ----------------------------------------------------------
// CreateEmployee создаёт нового сотрудника с указанным username и password_hash.
// При создании coins устанавливается значение по умолчанию (1000).
func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (CreateEmployeeRow, error) {
	row := q.db.QueryRow(ctx, createEmployee, arg.Username, arg.PasswordHash)
	var i CreateEmployeeRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Coins,
		&i.PasswordHash,
	)
	return i, err
}

const getCoinsByID = `-- name: GetCoinsByID :one
SELECT coins FROM employees WHERE id=$1
`

// ----------------------------------------------------------
// Получение баланса по ID сотрудника.
func (q *Queries) GetCoinsByID(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, getCoinsByID, id)
	var coins int32
	err := row.Scan(&coins)
	return coins, err
}

const getEmployeeByID = `-- name: GetEmployeeByID :one
SELECT 
  id,
  username,
  coins,
  created_at
FROM employees
WHERE id = $1
`

type GetEmployeeByIDRow struct {
	ID        int32
	Username  string
	Coins     int32
	CreatedAt pgtype.Timestamptz
}

// ----------------------------------------------------------
// GetEmployeeByID возвращает данные сотрудника по его идентификатору.
func (q *Queries) GetEmployeeByID(ctx context.Context, id int32) (GetEmployeeByIDRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeByID, id)
	var i GetEmployeeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Coins,
		&i.CreatedAt,
	)
	return i, err
}

const getEmployeeByUsername = `-- name: GetEmployeeByUsername :one
SELECT 
  id,
  username,
  password_hash,
  coins,
  created_at
FROM employees
WHERE username = $1
`

// GetEmployeeByUsername возвращает сотрудника по username.
func (q *Queries) GetEmployeeByUsername(ctx context.Context, username string) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployeeByUsername, username)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.Coins,
		&i.CreatedAt,
	)
	return i, err
}

const updateEmployeeCoins = `-- name: UpdateEmployeeCoins :exec
UPDATE employees
SET coins = coins + $2
WHERE id = $1 AND coins + $2 >= 0
`

type UpdateEmployeeCoinsParams struct {
	ID    int32
	Coins int32
}

// ----------------------------------------------------------
// UpdateEmployeeCoins обновляет баланс сотрудника.
// Параметр $2 может быть положительным (начисление) или отрицательным (списание).
// Здесь добавлена проверка, чтобы новый баланс не стал отрицательным.
func (q *Queries) UpdateEmployeeCoins(ctx context.Context, arg UpdateEmployeeCoinsParams) error {
	_, err := q.db.Exec(ctx, updateEmployeeCoins, arg.ID, arg.Coins)
	return err
}
